% classes_regles.tex

\section{Classes abstraites}\label{classes_abstraites}
Trois classes abstraites ont été définies, chacune permettant l'usage de certains
algorithmes sur l'ensemble de règles considéré.
Elles sont dites {\em abstraites} puisque déterminer si un ensemble de règles appartient
à l'une de ces classes est un problème non décidable.
De plus elles sont incomparables entre elles, et non exclusives. 

\subsection{Finite Expansion Set}\label{classes_abstraites_fus}
La première classe est définie comme assurant la finition des algorithmes de chaînage
avant. Ainsi tout ensemble de règles appartenant à cette classe peut être utilisé pour
les dérivations de ces algorithmes.
Dans le cas de certaines classes, il est par contre nécessaire d'ajouter des conditions
d'arrêt, celles-ci sont détaillées plus loin.

\subsection{Finite Unification Set}\label{classes_abstraites_fes}
La deuxième classe abstraite quant à elle assure la finition des algorithmes de chaînage
arrière. De la même manière que précedemment il est parfois nécessaire de modifier les
conditions d'arrêt.

\subsection{Bounded Treewidth Set}\label{classes_abstraites_bts}
La dernière définit les ensembles de règles où la production de nouvelles règles suit la
forme d'un arbre.
Cette classe ne permet pas l'utilisation direct d'algorithmes, mais par contre la classe
abstraite Greedy Bounded Treewidth qui est une spécialisation de celle-ci, s'assure que
le chaînage avant s'exécute en temps fini, et ce dès qu'un algorithme glouton de ... est
utilisé.


\section{Classes concrètes}\label{classes_concretes}
\input{src/classes_regles/concretes.tex}

\section{Combinaisons}\label{combine}
Les composantes fortement connexes du graphe de dépendances sont utilisées pour le 
{\em découper} de façon à attribuer des étiquettes différentes à celles-ci en fonction
des classes concrètes auxquelles son ensemble de règles appartient.

De plus une fois chaque sous ensemble étiqueté, il faut encore vérifier que celles-ci
sont compatibles entre elles.

Pour cela, nous définissons le graphe orienté des composantes fortement connexes associé
tel que son ensemble de sommets est l'ensemble des composantes du graphe, et
qu'il existe un arc entre deux composantes $C_i$ et $C_j$ si et seulement s'il existe un
arc d'un sommet de $C_i$ vers un sommet de $C_j$.
Par définition des composantes fortement connexes, ce graphe est évidemment sans
circuit.
%et les arcs de celui-ci influent directement sur la décidabilité de l'ensemble
%de règles.

On dit que $C_i$ {\em précède} $C_j$ s'il n'existe aucun arc de $C_j$ vers $C_i$, et on
note cette relation $C_i \triangleright C_j$.

De plus,
on associe à chaque $C_i$ une étiquette qui déterminera la classe abstraite considérée pour
cette composante.

pour que l'ensemble de règles soit décidable est la suivante :\\
$\{C_i : etiquette(C_i) = FES\} \triangleright \{C_i : etiquette(C_i) = GBTS\} \triangleright
\{C_i : etiquette(C_i) = FUS\}$
C'est à dire qu'aucune règle \fes ne doit dépendre d'une règle \fus ou \gbts, et
qu'aucune règle \gbts ne doit dépendre d'une règle \fus.

En effet les algorithmes de chaînage arrière par exemple réécrivent la requête jusqu'à ce
qu'elle corresponde à la base, tandis que ceux avant ajoutent des faits jusqu'à obtenir
la requête. Il est donc évident que si une composante n'accepte que le chaînage arrière,
il ne doit exister aucune règle de celle-ci de laquelle dépende une règle de la
composante acceptant uniquement le chaînage avant (si tel était le cas, cette règle ne
serait jamais déclenchée).


